#!/usr/bin/env python3

import ast
import argparse
import logging
import signal
import sys

from socketIO_client import SocketIO, LoggingNamespace

from gann.trader import Trader
from gann.offer import offer_bitcoin_de


class LogHandler:
    def __init__(self, trader):
        self.offer_id = 0
        self.trader = trader
        print("") # Write deletes the last line which is the status line.
        # This way we make sure it does
        # not delete the line before the start of the run.

    def write(self, output):
        sys.stdout.write("\033[F\033[K")
        self.offer_id = self.offer_id + 1
        print("  %6i  %s" % (self.offer_id, output))
        print('Money: %.2f€, Coins: %f, Bought: %s' % (
            self.trader.money/100.0,
            sum(self.trader.depot.values()),
            ["%f for %.2f€" % (self.trader.depot[price], price/100.0)
             for price in self.trader.depot]
        ), sep='', end='')

class PrintBroker:
    def __init__(self, output_log):
        self.output_log = output_log
        self.id = 0
        self.trader = None

    def try_sell(self, offer, amount):
        self.output_log.write(
            "%i Sold %f of %s depot: %s\n" %
            (self.trader.money, amount, offer, self.trader.depot))
        return True

    def try_buy(self, offer, amount):
        self.output_log.write(
            "%i bought %f of %s depot: %s\n" %
            (self.trader.money, amount, offer, self.trader.depot))
        return True

class Demo:
    """ Simulates a trader and prints trading activity."""
    def __init__(self, state_out, money=1000_00, depot={}, broker=None):
        self.trader = Trader(money=money,
                             depot=depot,
                             broker=broker)
        broker.trader = self.trader
        self.state_out = state_out

        logging.getLogger().addHandler(logging.StreamHandler(LogHandler(self.trader)))
        logging.getLogger().setLevel(logging.INFO)
        self.running = True

    def add_order(self, *args):
        self.trader.process_offer(offer_bitcoin_de(args[0]))
        self.state_out.seek(0)
        self.state_out.write(str({'money': self.trader.money,
                                  'depot': self.trader.depot}))
        # flush everythin else if previously written depot was larger.
        self.state_out.truncate()

    def remove_order(self, *args):
        pass

    def refresh_express_option(self, *args):
        pass

    def stop(self):
        """Stops the demo."""
        self.running = False

    def run(self):
        """ Runs the trader until stop() is calles."""
        target_socket = SocketIO('https://ws.bitcoin.de', 443, LoggingNamespace)
        target_socket.on('add_order', self.add_order)
        target_socket.on('remove_order', self.remove_order)
        target_socket.on('refresh_express_option', self.refresh_express_option)

        while self.running:
            target_socket.wait(seconds=2)

def main():
    parser = argparse.ArgumentParser(description="""A live demo to demonstrate
    the trader on bitcoin.de""")

    parser.add_argument('--trade-log', metavar='TRADE_LOGFILE',
                        type=argparse.FileType('w+'),
                        nargs=1,
                        default='trade_log.json',
                        help='Where to store the accepted trades.')

    parser.add_argument('--state-out', metavar='STATE_FILE',
                        type=argparse.FileType('w'),
                        nargs=1,
                        default='trader_state.json',
                        help='Where to store the backup of current depot.  '
                        'This can be used to restart the demo with a previous state.')

    parser.add_argument('--init-state', metavar='DEPOT_BACKUP',
                        type=argparse.FileType('r'),
                        nargs='?',
                        help='The state to start with.')

    parser.add_argument('--start-money', metavar='START_MONEY',
                        type=float,
                        nargs='?',
                        help='The initial money to start trading with in Euro.',
                        default=1000.00)

    args = parser.parse_args()
    init_state = {}
    if not args.init_state is None:
        init_state = ast.literal_eval(args.init_state.read())

    start_money = init_state.get('money', args.start_money * 100)
    start_depot = init_state.get('depot', dict())

    if start_money == 0.0 and not start_depot:
        print("No money and no depot specified, specify at least one.\n\n",
              file=sys.stderr)
        parser.print_help()
        sys.exit(1)

    demo = Demo(
        money=start_money,
        depot=start_depot,
        broker=PrintBroker(output_log=args.trade_log),
                state_out=args.state_out)

    signal.signal(signal.SIGINT, lambda sig, frame: demo.stop())
    demo.run()

    args.init_state.close()
    args.state_out.close()
    args.trade_log.close()
    print("\n\nStopped servus")


if __name__ == "__main__":
    main()
